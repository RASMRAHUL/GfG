1.  ZigZag Tree Traversal

vector <int> zigZagTraversal(Node* root)
    {
    	vector<int> result ;
    	if(root== NULL)
    	    return result;
    	queue<Node*> q;
    	q.push(root);
    	bool leftToright = true;
    	
    	while(!q.empty())
    	{
    	    int size = q.size();
    	    vector<int> ans(size);
    	    for(int i = 0; i<size;i++)
    	    {
    	        Node* frontNode = q.front();
    	        q.pop();
    	        
    	        int index = leftToright ? i:size-i-1;
    	        ans[index] = frontNode->data;
    	        
    	        if(frontNode->left){
    	            q.push(frontNode->left);
    	        }
    	        if(frontNode->right){
    	            q.push(frontNode->right);
    	        }
    	    }
    	   
    	   leftToright = !leftToright;
    	   for(auto i : ans)
    	   result.push_back(i);
    	    
    	}
    	
    	return result;
    }




2.  Boundary Traversal of binary tree


class Solution {
    private:
    void traverseLeft(Node* root, vector<int> &ans)
    {
        if((root == NULL) || (root->left == NULL && root->right == NULL))
            return;
        ans.push_back(root->data);
        
        if(root->left)
            traverseLeft(root->left, ans);
        else
            traverseLeft(root->right, ans);
    }
    
    void traverseLeaf(Node* root, vector<int> &ans)
    {
        if(root == NULL)
            return;
            
        if(root->left == NULL && root->right == NULL)
        {
            ans.push_back(root->data);
            return;
        }
        
        traverseLeaf(root->left, ans);
        traverseLeaf(root->right, ans);
        
    }
    
    void traverseRight(Node* root, vector<int> &ans)
    {
        if((root == NULL) || (root->left == NULL && root->right == NULL))
            return;
        
        if(root->right)
            traverseRight(root->right, ans);
        else
            traverseRight(root->left, ans);
            
        ans.push_back(root->data);
    }
public:
    vector <int> boundary(Node *root)
    {
        vector<int> ans;
        //base case
        if(root==NULL)
            return ans;
          
        ans.push_back(root->data);
        
        //for printing left node except leaf node.
        traverseLeft(root->left, ans);
    
        //for printing all leaf node
        traverseLeaf(root->left, ans);
        traverseLeaf(root->right, ans);
        
        //for printing right node except leaf node.
        traverseRight(root->right, ans);
        
        
        
        return ans;
    }
};
