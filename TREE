1.  ZigZag Tree Traversal

vector <int> zigZagTraversal(Node* root)
    {
    	vector<int> result ;
    	if(root== NULL)
    	    return result;
    	queue<Node*> q;
    	q.push(root);
    	bool leftToright = true;
    	
    	while(!q.empty())
    	{
    	    int size = q.size();
    	    vector<int> ans(size);
    	    for(int i = 0; i<size;i++)
    	    {
    	        Node* frontNode = q.front();
    	        q.pop();
    	        
    	        int index = leftToright ? i:size-i-1;
    	        ans[index] = frontNode->data;
    	        
    	        if(frontNode->left){
    	            q.push(frontNode->left);
    	        }
    	        if(frontNode->right){
    	            q.push(frontNode->right);
    	        }
    	    }
    	   
    	   leftToright = !leftToright;
    	   for(auto i : ans)
    	   result.push_back(i);
    	    
    	}
    	
    	return result;
    }




2.  Boundary Traversal of binary tree


class Solution {
    private:
    void traverseLeft(Node* root, vector<int> &ans)
    {
        if((root == NULL) || (root->left == NULL && root->right == NULL))
            return;
        ans.push_back(root->data);
        
        if(root->left)
            traverseLeft(root->left, ans);
        else
            traverseLeft(root->right, ans);
    }
    
    void traverseLeaf(Node* root, vector<int> &ans)
    {
        if(root == NULL)
            return;
            
        if(root->left == NULL && root->right == NULL)
        {
            ans.push_back(root->data);
            return;
        }
        
        traverseLeaf(root->left, ans);
        traverseLeaf(root->right, ans);
        
    }
    
    void traverseRight(Node* root, vector<int> &ans)
    {
        if((root == NULL) || (root->left == NULL && root->right == NULL))
            return;
        
        if(root->right)
            traverseRight(root->right, ans);
        else
            traverseRight(root->left, ans);
            
        ans.push_back(root->data);
    }
public:
    vector <int> boundary(Node *root)
    {
        vector<int> ans;
        //base case
        if(root==NULL)
            return ans;
          
        ans.push_back(root->data);
        
        //for printing left node except leaf node.
        traverseLeft(root->left, ans);
    
        //for printing all leaf node
        traverseLeaf(root->left, ans);
        traverseLeaf(root->right, ans);
        
        //for printing right node except leaf node.
        traverseRight(root->right, ans);
        
        
        
        return ans;
    }
};

3.Vertical Traversal of Binary Tree


vector<int> verticalOrder(Node *root)
    {
        map<int, map<int,vector<int> > > nodes;
        queue<pair<Node* , pair<int, int> > > q;
    
        vector<int> ans;
        if(root== NULL)
            return ans;
        
        q.push(make_pair(root, make_pair(0,0)));
        
        while(!q.empty())
        {
            pair<Node* , pair<int, int>> temp = q.front();
            q.pop();
            Node* frontNode = temp.first;
            //hd -> Horizontal Distances
            int hd = temp.second.first;
            int level = temp.second.second;
            
            nodes[hd][level].push_back(frontNode->data);
            
            if(frontNode->left)
                q.push(make_pair(frontNode->left, make_pair(hd-1,level+1)));
            
            if(frontNode->right)
                q.push(make_pair(frontNode->right, make_pair(hd+1, level+1)));
                
        }
        for(auto i : nodes)
        {
            for(auto j : i.second)
            {
                for(auto k : j.second)
                {
                    ans.push_back(k);
                }
                
            }
        }
        
        
        return ans;
    }
